---
title: 'Créer et Exploiter<br>une<br>Base de Données<br>sous<br>![R](images/logo_R.png)'
author: 'Mickaël CANOUIL, *Ph.D.*'
date: 'Jeudi 03 mai - Vendredi 04 mai'
monofont: "Source Code Pro"
monofontoptions: "Scale=0.7"
params:
  theme_dark: TRUE
  dpi: 300
  ggFontSize: 14
output:
  ioslides_presentation:
    css: template/shiny-slides.css
    highlight: zenburn
    incremental: false
    logo: template/logo_UMR.png
    smaller: true
    self_contained: true
---

```{r setup, include = FALSE}
options(stringsAsFactors = FALSE)

### Load packages and functions
# library(parallel)
library(grid)
library(scales)
library(broom)
library(viridis)
# library(readxl)
# library(writexl)
# library(cowplot)
# library(tableone)
library(Hmisc)
library(knitr)
library(rmarkdown)
library(kableExtra)
# library(tidyverse)

invisible(sapply(list.files(path = "../../DEV/Rfunctions/", full.names = TRUE), source))

options("width" = 80)
### Set knitr rmarkdown chunk options
opts_chunk$set(
  include = TRUE,
  echo = TRUE,
  warning = TRUE,
  message = TRUE,
  tidy = FALSE,
  crop = TRUE,
  autodep = FALSE,
  dpi = params$dpi,
  fig.path = "./images/",
  cache = FALSE,
  cache.path = "./",
  width = 80,
  comment = "#>",
  results = "hold"
)

### Define theme
library(ggplot2)
theme_dark <- params$theme_dark
theme_set(theme_black(base_size = params$ggFontSize))
plot_grid <- hijack(plot_grid, theme_dark = theme_dark)
scale_colour_viridis <- hijack(scale_colour_viridis, option = "viridis", begin = 2/5, end = 1, direction = -1)
scale_fill_viridis <- hijack(scale_fill_viridis, option = "viridis", begin = 2/5, end = 1, direction = -1)

options(tibble.print_max = 3, tibble.print_min = 3)
```

## Les Bases de Données et R {.flexbox .vcenter}

<img src="images/intro.png"></img> 

# Préparer sa session {.flexbox .vcenter}

<img src="images/logo_Rbig.png" class="auto-fadein"></img> 


## Trucs et astuces

*  Eviter de changer votre répertoire de travail avec `setwd()`,  
    c.-à-d. démarrer R directement au bon endroit ou définir un "Projet" dans Rstudio.
*  Ne pas utiliser le `.Rprofile` avec des options modifiant le comportant de R.
*  Désactiver la conversion automatique des chaînes de caractères en facteurs `options(stringsAsFactors = FALSE)`.
*  Ne pas utiliser `rm(list = ls())` pour "rafraichir" votre session.
*  Ne pas sauvegarder/charger `.Rdata` en quittant/démarrant votre session R.

<div class="columns-2">
<img src="images/rstudio_setup.png" width="350"></img>

<img src="images/rwindows_setup.png" width="350"></img>
</div>

# Le *tidyverse* {.flexbox .vcenter}

<img src="images/tidyverse.png" height="250" class="auto-fadein"></img> 

## Qu'est-ce-que le *tidyverse* ?

Un ensemble d'outils basés sur une philosophie/grammaire commune.
```{r, message = FALSE}
if (!"tidyverse"%in%rownames(installed.packages())) {
  install.packages("tidyverse")
}
library(tidyverse)
```


## Qu'est-ce-que le *tidyverse* ?

`library(tidyverse)` chargera les packages : 

* [readr](http://readr.tidyverse.org), importation.
* [tibble](http://tibble.tidyverse.org), classe d'objet "tibble".
* [dplyr](http://dplyr.tidyverse.org), manipulation.
* [tidyr](http://tidyr.tidyverse.org), mise en forme.
* [ggplot2](http://ggplot2.tidyverse.org), visualisation.
* [purrr](http://purrr.tidyverse.org), programmation.

Ces packages représentent la base du *tidyverse* et sont en constante évolution.
```{r, eval = FALSE}
tidyverse_update()
```


# *tibble* | comme un *data.frame*, mais en mieux ! {.flexbox .vcenter}

<img src="images/tibble.png" height="250" class="auto-fadein"></img>

## Pré-requis
```{r, message = FALSE}
library(tidyverse)
```

```{r}
tidyverse_conflicts()
```

## Construire un *tibble*

```{r}
tibble(
  x = 1:5, 
  y = 1, 
  z = x ^ 2 + y
)
```

```{r, error = TRUE}
data.frame(
  x = 1:5, 
  y = 1, 
  z = x ^ 2 + y
)
```


## Construire un *tibble*
Et avec des noms de variables "exotiques" ?
```{r}
data.frame(`1`= 1:3)
```

```{r}
tibble(
  `;)` = 1:5, 
  `42` = "1", 
  `€` = `;)` ^ 2 + as.numeric(`42`)
)
```

## Afficher un *data.frame*
Les méthodes `show()` et `print()` :  
```{r}
as.data.frame(mtcars)
```
```{r}
print(as.data.frame(mtcars))
```

## Afficher un *tibble*
Les méthodes `show()` et `print()` : 
```{r}
as_tibble(mtcars)
```
```{r}
print(as_tibble(mtcars))
```

## Afficher un *tibble*
La fonction `rownames_to_column()` (et `column_to_rownames()`) : 
```{r}
as_tibble(rownames_to_column(mtcars))
```
```{r}
print(as_tibble(rownames_to_column(mtcars)))
```


## Afficher un *tibble* : les options
Changer les options d'affichages d'un *tibble* :

* via `options()`
```{r, eval = FALSE}
options(tibble.print_max = n, tibble.print_min = m, dplyr.print_min = p)
```
Afficher les `n` premières lignes, s'il y a plus de `m` ligneset sur `p` colonnes.

* via `print()`
```{r, eval = FALSE}
print(x = DF, n = n, width = p))
```

* dans Rstudio via `View()`
```{r, eval = FALSE}
View(mtcars)
```

<img src="images/Rstudio_View.png"></img>


## Sélectionner une variable : `$`, `[` et `[[`

```{r}
mtcars$mpg
```

```{r}
mtcars[["mpg"]]
```

```{r}
mtcars[, "mpg"]
```

## Sélectionner une variable : `$`, `[` et `[[`

```{r}
as_tibble(mtcars)$mpg
```

```{r}
as_tibble(mtcars)[["mpg"]]
```

```{r}
as_tibble(mtcars)[, "mpg"]
```

## Assurer la rétro-compatibilité du code
De "vielles" fonctions limitées à la classe d'objet `data.frame` !
```{r}
tb <- as_tibble(mtcars)
class(tb)
```
```{r}
class(as.data.frame(tb))
```


## Exercices {#exe}

*  Comment savoir si un objet est de classe `tibble`, `data.frame`  ou encore `matrix` ?
*  Comment se comporte les opérations suivantes sur un `data.frame` et l'équivalent `tibble` ?  
    Quelle est la différence ?  
    ```{r, eval = FALSE}
    df <- data.frame(abc = 1, xyz = "a")
    df$x
    df[, "xyz"]
    df[, c("abc", "xyz")]
    ```
  
*  Comment extraire une colonne en utilisant une variable ? 
    ```{r}
    X <- "mpg"
    ```

## Exercices {#exe}

*  Manipuler des noms de variables non-conventionnelles :
    ```{r}
    annoying <- tibble(
      `1` = 1:10,
      `2` = `1` * 2 + rnorm(length(`1`))
    )
    ```
    1.  Extraire la variable nommée `1`.
    2.  Tracer un nuage de points de `1` par rapport à `2`.
    3.  Ajouter une colonne nommée `3` contenant le résultat de `2` divisé par `1`.
    4.  Renommer les colonnes avec leurs noms littéral: `"un"`, `"deux"` et `"trois"`.

## Pour aller plus loin ...

* Cheatsheets Rstudio : [https://www.rstudio.com/resources/cheatsheets/](https://www.rstudio.com/resources/cheatsheets/)

```{r, eval = FALSE}
vignette(package = "tibble")
```

<img src="images/screenshot_tibble.png" height="350"></img>


# %>% | *magrittr* : "Ceci n'est pas un pipe." {.flexbox .vcenter}

<img src="images/pipe.png" height="250" class="auto-fadein"></img>

## Pré-requis
```{r, message = FALSE}
library(pryr)
```

```{r, message = FALSE}
library(tidyverse)
```

```{r}
tidyverse_conflicts()
```

## Qu'est-ce-que le "pipe" ?
L'opérateur "pipe" (`%>%`) provient du package __magrittr__ développé par Stefan Milton Bache.

Par défaut `library(tidyverse)` s'occupe de charger l'opérateur "pipe".

__Exemple :__

*  `x %>% f` équivalent à `f(x)`
*  `x %>% f(y)` équivalent à `f(x, y)`
*  `x %>% f %>% g %>% h` équivalent à `h(g(f(x)))`
*  `f <- . %>% cos %>% sin` équivalent à `f <- function(.) sin(cos(.))`


## Pourquoi utiliser le "pipe" ?

Une aide à :

*  l'écriture du code.
*  la lisibilité du code.

<img src="images/xkcd_code_quality.png"></img>

Note : Raccourci `Ctrl+M` dans Rstudio pour faire apparaître un "pipe".

## Conserver les étapes
```{r, eval = FALSE}
x <- rnorm(25)
x1 <- sqrt(x)
x2 <- na.exclude(x1)
x3 <- x2<1
x4 <- table(x3)
x5 <- prop.table(x4)
x6 <- which.max(x5)
x7 <- names(x6)
```

<br>
Les inconvénients de cette écriture :

*  Obligation de nommer de façon explicite les différents objets.
*  Environnement surchargé d'objets peu utiles (`ls()`).
*  Utilisation plus importante de la mémoire vive ?
    ```{r, eval = FALSE}
    mtcars2 <- mtcars %>% mutate(cyl_fac = factor(cyl))
    
    pryr::object_size(mtcars)
    pryr::object_size(mtcars2)
    pryr::object_size(mtcars, mtcars2)
    ```

## Remplacer l'objet original 
```{r, eval = FALSE}
x <- rnorm(25)

x <- sqrt(x)
x <- na.exclude(x)
x <- x<1
x <- table(x)
x <- prop.table(x)
x <- which.max(x)
x <- names(x)
```

<br>
Les inconvénients de cette écriture :

*  Obligation de relancer tout le code pour débuguer.
*  Répétition du nom de l'objet (14 fois).

## Composer l'appel aux fonctions
```{r, eval = FALSE}
x <- rnorm(25)

names(
  which.max(
    prop.table(
      table(
        na.exclude(
          sqrt(x)
        )<1
      )
    )
  )
)

names(which.max(prop.table(table(na.exclude(sqrt(x))<1))))
```

<br>
Les inconvénients de cette écriture :

*  L'ordre des appels va de l'intérieur vers l'extérieur.
*  Les arguments peuvent se situés "loin" de la fonction.


## Utiliser le "pipe" 
```{r, eval = FALSE}
x %>% 
  sqrt() %>% 
  na.exclude() %>% 
  `<`(1) %>% 
  table() %>% 
  prop.table() %>% 
  which.max() %>% 
  names()
```

<br>
A éviter si :

*  le nombre d'étapes devient important.  
    Utiliser des objets intermédiaires avec des noms claires.
*  la séquence d'opération n'est pas linéaire.
*  les opérations nécéssitent plusieurs objets en entrée et/ou sortie.


## Pour aller plus loin ...

```{r, eval = FALSE}
vignette(package = "magrittr")
```

<img src="images/screenshot_magrittr.png" height="350"></img>


# *readr* & *readxl* | Importer des données {.flexbox .vcenter}

<div class="columns-2">
<img src="images/readr.png" height="250" class="auto-fadein"></img>

<img src="images/readxl.png" height="250" class="auto-fadein"></img>
</div>


## Pré-requis
```{r, message = FALSE}
library(readxl)
```

```{r, message = FALSE}
library(tidyverse)
```

```{r}
tidyverse_conflicts()
```

## Les fonctions de base de *readr*
Lire des tableaux rectangulaires :

* `read_csv()` : fichier avec séparateur virgule (".csv").
* `read_tsv()` : fichier avec séparateur tabulation.
* `read_table()` : fichier avec séparateur espace.
* `read_delim()` : forme générale (`delim = ""`).

Lire des données R (".rds") :

* `read_rds()` : surcouche de `readRDS()` (sans compression).

Lire des formats plus exotiques :
    
* `read_fwf()` : fichier à largeur fixe (nombre de caractères).
* `read_log()` : fichier de log provenant de serveur web Apache.

## Par rapport à celles de R : Entrée

* Nom homogène des fonctions et arguments .
* Plus rapide (moins rapide que *data.table*).
* ~~Auto-conversion en facteur.~~
* L'importation ne dépend pas des variables locales.
```{r}
locale()
```

## Par rapport à celles de R : Sortie

* Conversion des champs "date" au format `"%Y-%m-%d"`.
* Conversion des champs date/heure dans la norme ISO8601.  
    Par exemple : 
    * 07:57:59Z
    * 2018-04-13T07:57:59Z
* Noms des colonnes inchangés.
* Renvoie un objet *tibble*.
* Pas de nom de ligne.


## Dans la pratique | Lire un CSV avec *base*

```{r}
ratings <- read.csv(
  file = "./materials/ratings.csv"
)
str(ratings[0, ])
```

## Dans la pratique | Lire un CSV avec *readr*

```{r}
ratings <- read_csv(
  file = "./materials/ratings.csv"
)
```

## Dans la pratique | Lire un "texte" avec *base*

```{r}
read.csv(
  text = "a,b,c
    1,2,3
    4,5,6"
)
```

## Dans la pratique | Lire un "texte" avec *readr*

```{r}
read_csv(
  "a,b,c
  1,2,3
  4,5,6"
)
```

## Les arguments de *readr*

* L'argument `skip = n`
    ```{r}
    read_csv("Une ligne de métadonnées
      x,y,z
      1,2,3", skip = 1)
    ```
* L'argument `comment = "#"`
    ```{r}
    read_csv("# Une ligne de commentaires
      x,y,z
      1,2,3", comment = "#")
    ```

## Les arguments de *readr*

* L'argument `col_names = FALSE`
    ```{r}
    read_csv("1,2,3\n4,5,6", col_names = FALSE)
    ```
    
* Utiliser `col_names`pour nommer les colonnes
    ```{r}
    read_csv("1,2,3\n4,5,6", col_names = c("a", "b", "c"))
    ```
    
## Les arguments de *readr*

* L'argument `na = "."`
    ```{r}
    read_csv("a,b,c\n1,2,3\n4,.,6", na = ".")
    ```
    
* L'argument `col_types`
    ```{r}
    read_csv(
      "a,b,c\n1,x,2018-05-03\n4,y,2018-05-04", 
      col_types = list(col_integer(), col_character(), col_date(format = "%Y-%m-%d"))
    )
    ```

## Exercices {#exe}
* Quelle fonction utiliseriez-vous pour importer un document avec `|` en séparateur ?
    
* Un fichier CSV peut parfois contenir une virgule dans un champ.  
    Astuce : utilisez des guillemets simple `'` ou double `"`.
      1. Quel est le caractère par défaut utiliser par `read_csv()` ?  
      2. Quelle fonction et argument utiliser pour changer ce caractère ?
      3. Quelle fonction et avec quel valeur argument liriez-vous la chaîne suivante ?
    ```{r, eval = FALSE}
    "x,y\n1,'a,b'"
    ```
    
* Identifier les problèmes des lignes suivantes.  
    ```{r, eval = FALSE}
    read_csv("a,b\n1,2,3\n4,5,6")
    read_csv("a,b,c\n1,2\n1,2,3,4")
    read_csv("a,b\n\"1")
    read_csv("a,b\n1,2\na,b")
    read_csv("a;b\n1;3")
    ```

## Les alternatives à *readr* {.flexbox .vcenter}

```{r, echo = FALSE}
data.frame(
  check.names = FALSE,
  "Type de données" = rev(c("Logiciel Statistique", "Excel", 'Fichier "Texte"')),
  Package = rev(c("__*haven*__", "__*readxl*__", "__*readr*__")),
  Alternatives = rev(c("foreign, sas7bdat, readstata13", "gdata, openxlsx, XLConnect, xlsx", "base, data.table"))
) %>% 
  kable(font_size = 18, align = "c", row.names = FALSE)
```

## Quelques benchmark ! {.flexbox .vcenter}

<img src="images/xkcd_violin_plots.png"></img>


## Quelques benchmark : Lecture  {.flexbox .vcenter}
```{r read_benchmark, message = FALSE, echo = FALSE}
filename <- "./materials/ratings.csv"
microbenchmark::microbenchmark(
  {dta <- utils::read.csv(filename)},
  {dta <- readr::read_csv(filename)},
  {dta <- data.table::fread(filename)}
) %>% 
  as.data.frame() %>% 
  mutate(
    t = microbenchmark:::convert_to_unit(time, "s"),
    expr = factor(
      gsub("\\{ *dta <- (.*)\\(.*", "\\1", expr),
      levels = c("utils::read.csv", "readr::read_csv", "data.table::fread")
    )
  ) %>% 
    ggplot(aes(x = expr, y = t, fill = expr)) +
      geom_violin(colour = "white") +
      scale_fill_viridis(discrete = TRUE, guide = FALSE) +
      labs(y = "Time (s)", x = NULL) +
      scale_y_continuous(limits = c(0, NA)) +
      coord_flip()
```


## Quelques benchmark : Ecriture{.flexbox .vcenter}
```{r write_benchmark, message = FALSE, echo = FALSE}
filename <- paste0(tempdir(), "/ratings.csv")
microbenchmark::microbenchmark(
  {utils::write.csv(x = ratings, file = filename, row.names = FALSE)},
  {readr::write_csv(x = ratings, path = filename)},
  {data.table::fwrite(x = ratings, file = filename)}
) %>% 
  as.data.frame() %>% 
  mutate(
    t = microbenchmark:::convert_to_unit(time, "s"),
    expr = factor(
      gsub("\\{ *(.*)\\(.*", "\\1", expr), 
      levels = c("utils::write.csv", "readr::write_csv", "data.table::fwrite"))
  ) %>% 
    ggplot(aes(x = expr, y = t, fill = expr)) +
      geom_violin(colour = "white") +
      scale_fill_viridis(discrete = TRUE, guide = FALSE) +
      labs(y = "Time (s)", x = NULL) +
      scale_y_continuous(limits = c(0, NA)) +
      coord_flip()
```


## Exporter des données vers un fichier
*readr* inclut également des fonctions d'écriture `write_*()`.

* Les chaînes de caractères sont en UTF-8.
    <img src="images/xkccd_unicode.png"></img>
* Les dates et date/heure sont au format ISO8601

__Exemple__ :

```{r, eval = FALSE}
readr::write_csv(x = ratings, path = "ratings.csv")
```
```{r, eval = FALSE}
writexl::write_xlsx(x = ratings, path = "ratings.xlsx")
```


# *dplyr* | Une grammaire de la manipulation des données {.flexbox .vcenter}

<img src="images/dplyr.png" height="250" class="auto-fadein"></img>


## *dplyr* : Le pipe et des fonctions utiles {.flexbox .vcenter}

<img src="images/xkcd_bad_code.png"></img>


## Pré-requis
```{r, message = FALSE}
library(tidyverse)
```

```{r}
tidyverse_conflicts()
```

```{r, echo = FALSE}
options(tibble.print_max = 10, tibble.print_min = 10)
```


## Les fonctions de base

5 (+1) fonctions clés de *dplyr* :

1. Sélectionner des observations par valeur (`filter()`).
2. Trier les lignes (`arrange()`).
3. Sélectionner des colonnes (`select()`).
4. Ajouter des colonnes en fonction des colonnes préexistantes (`mutate()`).
5. Résumer des valeurs (`summarise()`).

6. `group_by()` pour travailler sur des sous-ensembles d'un jeu de données.


## Les fonctions de base

Une syntaxe commune :

* le premier argument est un objet `data.frame`.
* Le second argument décrit l'action à effectuer (noms de variable sans guillemets).
* Renvoie un `data.frame` (ou `tibble`).


## Sélectionner des lignes
```{r, message = FALSE}
ratings <- read_csv(file = "./materials/ratings.csv")
```

```{r}
### <b>
filter(ratings, `Your Rating` >= 9, `IMDb Rating` >= 9)
### </b>
```

```{r, message = FALSE}
read_csv(file = "./materials/ratings.csv") %>% 
### <b>
  filter(`Your Rating` >= 9 & `IMDb Rating` >= 9)
### </b>
```


## Exercices {#exe}



## Réordonner des lignes
```{r, message = FALSE}
read_csv(file = "./materials/ratings.csv") %>% 
### <b>
  arrange(desc(`Date Rated`)) ### </b>
```


## Exercices {#exe}



## Sélectionner des colonnes
Des aides à la sélection :

* `starts_with("abc")` : noms commençant par "abc".
* `ends_with("xyz")` : noms finissant par "xyz".
* `contains("ijk")` : noms contenant "ijk".
* `matches("(.)\\1")` : noms correspondant à l'expression régulière.
* `num_range("x", 1:3)`: noms correspondant à `x1`, `x2` et `x3`.

```{r, echo = FALSE}
options(tibble.print_max = 4, tibble.print_min = 4)
```

```{r, message = FALSE}
read_csv(file = "./materials/ratings.csv") %>% 
  arrange(desc(`Date Rated`)) %>% 
### <b>
  select(Title, ends_with("Rating"))
### </b>
```

```{r, echo = FALSE}
options(tibble.print_max = 10, tibble.print_min = 10)
```

## Exercices {#exe}



## Ajouter des colonnes
```{r, message = FALSE}
read_csv(file = "./materials/ratings.csv") %>% 
  arrange(desc(`Date Rated`)) %>% 
### <b>
  mutate(Rating_is_better = `Your Rating`>=`IMDb Rating`) %>% 
### </b>
  select(Title, `Your Rating`, `IMDb Rating`, Rating_is_better)
```


## Exercices {#exe}



## Résumer les données
```{r, message = FALSE}
read_csv(file = "./materials/ratings.csv") %>%  
### <b>
  summarise(
    n_movies = n(),
    my_average_rating = mean(`Your Rating`),
    users_average_rating = mean(`IMDb Rating`),
    oldest_rating = min(`Date Rated`),
    newest_rating =  max(`Date Rated`)
  )
### </b>
```


## Exercices {#exe}



## Utiliser `group_by()`
```{r, message = FALSE}
read_csv(file = "./materials/ratings.csv") %>% 
  mutate(
    Year = lubridate::year(`Date Rated`)
  ) %>% 
  filter(Year!="2014") %>% 
### <b>
  group_by(Year) %>% 
### </b>
  summarise(
    n_movies = n(),
    my_average_rating = mean(`Your Rating`),
    users_average_rating = mean(`IMDb Rating`)
  ) %>% 
  arrange(desc(Year))
```


## Exercices {#exe}



## Pour aller plus loin ...

* Cheatsheets Rstudio : [https://www.rstudio.com/resources/cheatsheets/](https://www.rstudio.com/resources/cheatsheets/)

* Site de dplyr : [dplyr.tidyverse.org](https://dplyr.tidyverse.org/)

```{r, eval = FALSE}
vignette(package = "dplyr")
```

<img src="images/screenshot_dplyr.png" height="350"></img>


# *DBI* | Importer depuis une base de données  {.flexbox .vcenter}

<img src="images/database.png" height="250" class="auto-fadein"></img>


## Pré-requis
```{r, message = FALSE}
library(DBI)
```
```{r, message = FALSE}
library(odbc)
```
```{r}
tidyverse_conflicts()
```


## Démarrer PostgreSQL

* Lancez PostgreSQL via le raccourci "SQL Shell (psql)".

* Laissez les valeurs par défaut (pressez "Entrée").

<img src="images/pgsql_warning.png"></img>


## Démarrer PostgreSQL
Pour retirer le message d'avertissement, ajouter "chcp 1252" dans le fichier ".bat".

<img src="images/pgsql_bat.png"></img>


## Commandes psql

* `\?` pour l'aide des commandes psql.
* `\q` quitter.
* `\h` aide des commandes sql.
* `\l` liste des bases de données.
* `\c` se connecter à une base.
* `\d` [nom] pour la description d'une table, d'un index, séquence, vue.
* `\d` liste des relations (tables, vues et séquences).
* `\i` nom_fichier.sql exécuter un fichier de commandes SQL.


## Base, utilisateur et droits en SQL

* Créer un utilisateur.
    ```{sql, eval = FALSE}
    CREATE ROLE rdb LOGIN password 'rdbpass';
    ```

* Créer une base.
    ```{sql, eval = FALSE}
    CREATE DATABASE datawarehouse;
    ```

* Modifier le propriètaire d'une base.
    ```{sql, eval = FALSE}
    ALTER DATABASE datawarehouse OWNER TO 'rdb';
    ```


## Base, utilisateur et droits en R

Des connecteurs :

* [RMySQL](https://github.com/rstats-db/RMySQL#readme): MySQL et MariaDB.
* [RPostgreSQL](https://cran.r-project.org/package=RPostgreSQL): Postgres et Redshift.
* [RSQLite](https://github.com/rstats-db/RSQLite): base de donnée SQLite intégrée.
* [odbc](https://github.com/rstats-db/odbc#odbc): protocoles de connection libre.
* [bigrquery](https://github.com/rstats-db/bigrquery): Google BigQuery.


## Base, utilisateur et droits en R

* Identifier le driver de connection.
```{r}
odbcListDrivers() %>% 
  filter(attribute=="DriverODBCVer") %>% 
  select(-attribute)
```


## Base, utilisateur et droits en R

* Initier la connection.
```{r}
con <- dbConnect(
  drv = odbc(),
  driver = "PostgreSQL ODBC Driver(UNICODE)",
  server = "localhost",
  port = 5432,
  database = "postgres",
  uid = "postgres",
### <b>
  password = "password"
### </b>
)
```
```{r, eval = FALSE}
con <- dbConnect(
  drv = odbc(),
  driver = "PostgreSQL ODBC Driver(UNICODE)",
  server = "localhost",
  port = 5432,
  database = "postgres",
  uid = "postgres",
### <b>
  password = rstudioapi::askForPassword("Mot de passe :")
### </b>
)
```

  
  
## Base, utilisateur et droits en R

* Créer un utilisateur.
    ```{r}
    dbSendQuery(con, SQL("CREATE ROLE rdb LOGIN password 'rdbpass';"))
    ```
* Créer une base.
    ```{r}
    dbSendQuery(con, SQL("CREATE DATABASE datawarehouse;"))
    ```


## Base, utilisateur et droits en R

* Modifier le propriètaire d'une base.
    ```{r}
    dbSendQuery(con, SQL("ALTER DATABASE datawarehouse OWNER TO rdb;"))
    ```

* Se déconnecter de la base.
    ```{r}
    dbDisconnect(con)
    ```
    
## Créer des tables en SQL depuis R

* Se connecter en tant que "rdb".
    ```{r}
    con <- dbConnect(
      drv = odbc(),
      driver = "PostgreSQL ODBC Driver(UNICODE)",
      server = "localhost",
      database = "datawarehouse",
      port = 5432,
    ### <b>
      uid = "rdb",
      password = "rdbpass"
    ### </b>
    )
    ```


## Créer des tables en SQL depuis R

* Lister les tables.
    ```{r}
    dbListTables(con)
    ```

* Créer la table *mtcars*.
    ```{r}
    mtcars %>% 
      rownames_to_column(var = "car") %>% 
      mutate(const = gsub(" .*", "", car)) %>% 
      select(const, everything()) %>% 
      ### <b>
      dbWriteTable(con, "mtcars", .)
      ### </b>
    ```

* Lister les tables.
    ```{r}
    dbListTables(con)
    ```
    

## Faire des requêtes en SQL depuis R

* Lister les champs d'une table.
    ```{r}
    dbListFields(con, "mtcars")
```

* Lire une table.
    ```{r, echo = FALSE}
    options(tibble.print_max = 5, tibble.print_min = 5)
    ```
    ```{r}
    ### <b>
    dbReadTable(con, "mtcars") %>% 
    ### </b>
      as_tibble()
    ```


## Faire des requêtes en SQL depuis R
```{r, echo = FALSE}
options(tibble.print_max = 10, tibble.print_min = 10)
```

* Sélectioner les voitures du constructeur Mercedes.
    ```{r}
    res <- dbSendQuery(con, "SELECT * FROM mtcars WHERE const='Merc'")
    dbFetch(res)
    ```

* Libérer les ressources occupées par la requête.
    ```{r, message = FALSE}
    ### <b>
    dbClearResult(res)
    ### </b>
    dbDisconnect(con)
    ```


## Exercices {#exe}

* En tant qu'utilisateur "postgres", créez une base "movies".  
    Faire de "imdb_user" le propriètaire de cette base.
    
* En tant qu'utilisateur "imdb_user", exportez le fichier "ratings.csv" vers la base.
    Remplacez les espaces par des underscores dans les noms de colonnes.
    
* Listez les noms de colonnes de la table créée.

* Utilisez une requête SQL pour compter le nombre de films pour chaque note (`Your Rating`)  
    Importer le résultat localement sous la forme d'un *tibble*.
    
* Sélectionnez les films notés entre le 1er janvier 2017 et le 31 décembre 2017.  
    Exportez cette table vers la base de données.


## Exercices {#exe}
* En tant qu'utilisateur "postgres", créez une base "movies".  
    Faire de "imdb_user" le propriètaire de cette base.
    ```{r, warning = FALSE, message = FALSE, results = "hide"}
    con <- dbConnect(
      drv = odbc(),
      driver = "PostgreSQL ODBC Driver(UNICODE)",
      server = "localhost",
      database = "datawarehouse",
      port = 5432,
      uid = "postgres",
      password = "password"
    )
    dbSendQuery(con, SQL("CREATE ROLE imdb_user LOGIN password 'password';"))
    dbSendQuery(con, SQL("CREATE DATABASE movies;"))
    dbSendQuery(con, SQL("ALTER DATABASE Movies OWNER TO imdb_user;"))
    dbDisconnect(con)
    ```


## Exercices {#exe}
* En tant qu'utilisateur "imdb_user", exportez le fichier "ratings.csv" vers la base.
    Enlevez les espaces dans les noms de colonnes.
    ```{r, warning = FALSE, message = FALSE, results = "hide"}
    ratings <- read_csv(file = "./materials/ratings.csv") %>% 
      `colnames<-`(gsub(" ", "", colnames(.)))
    ```
    ```{r, warning = FALSE, message = FALSE, results = "hide"}
    con <- dbConnect(
      drv = odbc(),
      driver = "PostgreSQL ODBC Driver(UNICODE)",
      server = "localhost",
      database = "movies",
      port = 5432,
      uid = "imdb_user",
      password = "password"
    )
    dbWriteTable(con, "ratings", ratings)
    ```

## Exercices {#exe}
* Listez les noms de colonnes de la table créée.
    ```{r, warning = FALSE, message = FALSE, results = "hide"}
    dbListFields(con, 'ratings')
    ```

## Exercices {#exe}
* Utilisez une requête SQL pour compter le nombre de films pour chaque note (`"YourRating"`).  
    Importer le résultat localement sous la forme d'un *tibble*.
    ```{r, warning = FALSE, message = FALSE, results = "hide"}
    dbSendQuery(
      conn = con, 
      statement = SQL(
        'SELECT "YourRating", COUNT(*) as count FROM ratings GROUP BY "YourRating";'
      )
    ) %>% 
      dbFetch() %>% 
      as_tibble()
    ```

## Exercices {#exe}
* Sélectionnez les films notés entre le 1er janvier 2017 et le 31 décembre 2017.  
    Exportez cette table vers la base de données.
    ```{r, warning = FALSE, message = FALSE, results = "hide"}
    dbSendQuery(
      conn = con, 
      statement = SQL(
        'SELECT * 
          FROM ratings 
          WHERE "DateRated">=\'2017-01-01\' AND "DateRated"<=\'2017-12-31\';'
      )
    ) %>% 
      dbFetch()%>% 
      dbWriteTable(con, "ratings2017", .)
    
    dbListTables(con)
    ```
```{r, echo = FALSE, warning = FALSE, message = FALSE, results = "hide"}
dbDisconnect(con)
```


## Pour aller plus loin ...

Liste de diffusion autour du package *DBI*: [r-sig-db](https://stat.ethz.ch/mailman/listinfo/r-sig-db).

```{r, eval = FALSE}
vignette(package = "DBI")
```

<img src="images/screenshot_dbi.png"></img>


# *dplyr* & *dbplyr* | Une grammaire SQL généralisée {.flexbox .vcenter}

<img src="images/dplyr.png" height="250" class="auto-fadein"></img>


## Pré-requis
```{r, echo = FALSE}
options(tibble.print_max = 4, tibble.print_min = 4)
```
```{r, message = FALSE}
library(DBI)
```
```{r, message = FALSE}
library(odbc)
```
```{r, message = FALSE}
library(tidyverse)
```
```{r, message = FALSE}
library(dbplyr)
```
```{r}
tidyverse_conflicts()
```


## *dbplyr* : Premiers pas avec *dplyr*

* Connection sur une base de donnée SQL intégrée (package *RSQLite*).
    ```{r, eval = FALSE}
    con <- dbConnect(RSQLite::SQLite(), path = ":memory:")
    ```

* Connection à la base PostgreSQL.
    ```{r}
    con <- dbConnect(
      drv = odbc(),
      driver = "PostgreSQL ODBC Driver(UNICODE)",
      server = "localhost",
      database = "movies",
      port = 5432,
      uid = "imdb_user",
      password = "password"
    )
    ```


## *dbplyr* : Premiers pas avec *dplyr*

* Remplir la base.
    ```{r, message = FALSE}
    ratings <- read_csv(file = "./materials/ratings.csv") %>% 
      `colnames<-`(gsub(" ", "", colnames(.))) %>% 
      mutate(Year = lubridate::year(DateRated))
    ```
    ```{r, message = FALSE}
    copy_to(
      dest = con, 
      df = ratings, 
      name = "ratings_idx",
      temporary = FALSE, 
      indexes = list(
        "DateRated", 
        "YourRating", 
        "Title", 
        "Year"
      ),
      overwrite = TRUE
    )
    ```

Note : `temporary = TRUE` permet de rendre la table uniquement disponible à la connection en cours et uniquement pendant celle-ci.


## *dbplyr* : Premiers pas avec *dplyr*

* Faire une référence à une table depuis une connection.
    ```{r}
    ratings_db <- tbl(con, "ratings")
    class(ratings_db)
    ```

* Afficher l'objet.
    ```{r}
    ratings_db
    ```

## Manipuler une base avec *dplyr*

* Faire des requêtes sans SQL.
```{r}
date_sevendaysago <- (Sys.Date()-7)

ratings_db %>% 
  filter(DateRated > date_sevendaysago) %>% 
  select(Title, DateRated, YourRating, IMDbRating)
```


## Manipuler une base avec *dplyr*

* Faire des opérations en SQL sans SQL.
```{r}
ratings_db %>% 
  group_by(Year) %>% 
  summarise(
    N = n(),
    AvgRating = mean(YourRating)
  ) %>% 
  arrange(Year)
```


## Manipuler une base avec *dplyr*

* *dplyr* et *tbl_df*.
    ```{r}
    ratings_summary <- ratings %>% 
      group_by(Year) %>% 
      summarise(
        N = n(),
        AvgRating = mean(YourRating)
      ) %>% 
      arrange(Year)
    ```
    ```{r}
    str(ratings_summary, 1)
    ```


## Manipuler une base avec *dplyr*

* *dplyr* et *tbl_sql*.
    ```{r}
    ratings_summary_db <- ratings_db %>% 
      group_by(Year) %>% 
      summarise(
        N = n(),
        AvgRating = mean(YourRating)
      ) %>% 
      arrange(Year)
    ```
    ```{r}
    str(ratings_summary_db, 1)
    ```


## Manipuler une base avec *dplyr*

* L'envoi de la requête ne s'effectue qu'à la fin ou à l'affichage de l'objet.
    ```{r}
    ratings_summary_db %>% 
      print()
    ```


## Manipuler une base avec *dplyr*

* Les données ne sont jamais téléchargées dans la session R (sauf mention explicite).
    ```{r}
    ratings_summary_db %>% 
      collect()
    ```


## Retour au SQL avec *dplyr*

* Que fait *dplyr* pour effectuer la commande précédente `ratings_summary_db` ?
    ```{r}
     ratings_summary_db %>% 
      show_query()
    ```
    
* Traduire du R en requête SQL.
```{r}
translate_sql(head(ratings_db))
```


## Exercices {#exe}

* Comment *dbplyr* traduit les fonctions `as.numeric()` et `as.character()` ?

* Comment *dbplyr* traduit l'opérateur `^` ?

* Comment *dbplyr* traduit les fonctions `mean()`et `sd()` ?  
    Et avec`na.rm = TRUE` ?


## Exercices {#exe}

* Comment *dbplyr* traduit les fonctions `as.numeric()` et `as.character()` ?
    ```{r}
    translate_sql(as.numeric(x))
    ```
    ```{r}
    translate_sql(as.character(x))
    ```


## Exercices {#exe}

* Comment *dbplyr* traduit l'opérateur `^` ?
    ```{r}
    translate_sql(x^2)
    ```
    ```{r}
    tbl(con, sql('select 1 as x')) %>%
      mutate(sqr = x^2)
    ```


## Exercices {#exe}

* Comment *dbplyr* traduit les fonctions `mean()`et `sd()` ?  
    Et avec `trim = 0.05` ou `na.rm = TRUE` ?
    ```{r}
    translate_sql(mean(x))
    ```
    ```{r, error = TRUE}
    translate_sql(mean(x, trim = 0.05))
    ```
    ```{r}
    translate_sql(mean(x, na.rm = TRUE))
    ```
    

## *dplyr* > SQL > ~~*tbl* ?~~ > `collect()` > *tbl* 

* Rappatrier les données d'une requête via `collect()`
    ```{r}
    ratings_summary <- ratings_summary_db %>% 
      collect()
    class(ratings_summary)
    ```

## *dplyr* > SQL > ~~*tbl* ?~~ > `collect()` > *tbl* 

* Connaître les dimmensions de l'objet avant `collect()` ?
    ```{r}
    tally(ratings_summary_db)
    ```


## Exercices {#exe}

* Utilisez les fonctions `head()` , `tail()` et `nrow()` sur l'une des tables exportées.  
    Que se passe-t'il et pourquoi ?


## Exercices {#exe}

* Utilisez les fonctions `head()` , `tail()` et `nrow()` sur l'une des tables exportées.  
    Que se passe-t'il et pourquoi ?
    ```{r, warning = FALSE}
    ratings_summary_db %>% head(1)
    ```
    ```{r, error = TRUE}
    ratings_summary_db %>% tail()
    ```
    ```{r, error = TRUE}
    ratings_summary_db %>% nrow()
    ```


## *dplyr*, `explain()` to me

```{r}
explain(ratings_summary_db)
```

```{r, echo = FALSE, warning = FALSE, message = FALSE}
rm(ratings_db, ratings_summary_db)
dbDisconnect(con)
```

## Une base de données relationnel

* Schéma des tables du package *nycflights13*.

<img src="images/nycflights13.png"></img>


## Exercices (Partie I) {#exe}
```{r, echo = FALSE}
options(tibble.print_max = 10, tibble.print_min = 10)
```

* Connectez vous à la base "datawarehouse" en tant que "rdb".

* Créez une table "mtcars" avec le jeu de données `mtcars`.  
    Comparez les fonctions `dplyr::copy_to()` (en utilisant l'argument `temporary`) et `DBI::dbWriteTable()`.
    
* Modifiez `mtcars` en passant les noms de lignes dans une colonne 
et en ajoutant une colonne constructeur `const`.  
    Exporter l'objet `mtcars` vers la base. Que se passe-t'il ? (argument `overwrite`).

* Créez dans la base "datawarehouse" l'ensemble des tables de `nycflights13`.  
    Vérifiez que les tables sont bien créées.
    
* Effectuez la jointure de `planes`et `flights` pour identifier les 3 constructeurs présentant le plus grand nombre d'heures de vol (`?dplyr::join`).  
    Quelle est la requête SQL réalisée ?


## Exercices (Partie I) {#exe}

* Connectez vous à la base "datawarehouse" en tant que "rdb".
    ```{r}
    con <- dbConnect(
      drv = odbc(),
      driver = "PostgreSQL ODBC Driver(UNICODE)",
      server = "localhost",
      database = "datawarehouse",
      port = 5432,
      uid = "rdb",
      password = "rdbpass"
    )
    ```

## Exercices (Partie I) {#exe}

* Créez une table "mtcars" avec le jeu de données `mtcars`.  
    Comparez les fonctions `dplyr::copy_to()` (en utilisant l'argument `temporary`) et `DBI::dbWriteTable()`.
    ```{r}
    copy_to(con, mtcars, "mtcars", temporary = TRUE, overwrite = TRUE)
    dbListTables(con)
    ```
    ```{r}
    copy_to(con, mtcars, "mtcars", temporary = FALSE, overwrite = TRUE)
    dbListTables(con)
    ```
    ```{r}
    dbWriteTable(con, "mtcars", mtcars, overwrite = TRUE)
    dbListTables(con)
    ```
    
    
## Exercices (Partie I) {#exe}
* Modifiez `mtcars` en passant les noms de lignes dans une colonne 
et en ajoutant une colonne constructeur `const`.  
    Exporter l'objet `mtcars` vers la base. Que se passe-t'il ? (argument `overwrite`).
    ```{r}
    mtcars %>% 
      rownames_to_column(var = "car") %>% 
      mutate(const = gsub(" .*", "", car)) %>% 
      select(const, everything()) %>% 
      dbWriteTable(con, "mtcars", ., overwrite = TRUE)
    ```


## Exercices (Partie I) {#exe}

* Créez dans la base "datawarehouse" l'ensemble des tables de `nycflights13`.  
    Vérifiez que les tables sont bien créées.
    ```{r, eval = FALSE}
    library(nycflights13)
    dbWriteTable(con, "flights", flights)
    dbWriteTable(con, "airports", airports)
    dbWriteTable(con, "planes", planes)
    dbWriteTable(con, "weather", weather)
    dbWriteTable(con, "airlines", airlines)
    
    dbListTables(con)
    ```


## Exercices (Partie I) {#exe}

* Créez dans la base "datawarehouse" l'ensemble des tables de `nycflights13`.  
    Vérifiez que les tables sont bien créées.
    ```{r}
    library(nycflights13)
    nycflights13_db <- ls("package:nycflights13") %>% 
      lapply(., function(df) { 
        copy_to(
          df = get(df), 
          dest = con, 
          name = df, 
          overwrite = TRUE, 
          temporary = TRUE
        ) 
      }) %>% 
      `names<-`(ls("package:nycflights13"))
    ```
    ```{r}
    dbListTables(con)
    ```


## Exercices (Partie I) {#exe}

* Effectuez la jointure de `planes`et `flights` pour identifier les 3 constructeurs présentant le plus grand nombre d'heures de vol (`?dplyr::join`).
    ```{r, warning = FALSE}
    longest_air_time_db <- nycflights13_db[["flights"]] %>%
      inner_join(nycflights13_db[["planes"]], by = "tailnum") %>%
      group_by(manufacturer) %>% 
      summarise(total_air_time = sum(air_time)/60) %>% 
      arrange(desc(total_air_time)) %>%
      select(manufacturer, total_air_time) %>% 
      head(3)
    longest_air_time_db
    ```

## Exercices (Partie I) {#exe}

* Effectuez la jointure de `planes`et `flights` pour identifier les 3 constructeurs présentant le plus grand nombre d'heures de vol (`?dplyr::join`).
    Quelle est la requête SQL réalisée ?
    ```{r, tidy = TRUE, tidy.opts = list(width.cutoff = 80)}}
    longest_air_time_db %>% show_query()
    ```

## Exercices (Partie II) {#exe}
```{r, echo = FALSE}
options(tibble.print_max = 5, tibble.print_min = 5)
```

* Calculez la moyenne des températures `temp` (table `weather`) par station `origin` et par année `year`.  
    Comparez le résultat entre la version calculée sur l'objet local et sur la base de donnée. 

* Comptez le nombre d'aéroport dont le code `dest` (table `flights`) commence par la lettre "A" ([Wildcard SQL](https://www.w3schools.com/sql/sql_wildcards.asp); `%like%`).

* Créez une nouvelle colonne `origin_dest` à partir des colonnes `origin` et `dest`.


## Exercices (Partie II) {#exe}

* Calculez la moyenne des températures `temp` (table `weather`) par station `origin` et par année `year`.  
    Comparez le résultat entre la version calculée sur l'objet local et sur la base de donnée.
    ```{r}
    nycflights13::weather %>% 
      group_by(origin, year) %>%  summarise(avg_temp = mean(temp))
    ```
    ```{r, warning = FALSE, eval= FALSE}
    nycflights13_db[["weather"]] %>% 
      group_by(origin, year) %>% summarise(avg_temp = mean(temp))
    ```


## Exercices (Partie II) {#exe}

* Calculez la moyenne des températures `temp` (table `weather`) par station `origin` et par année `year`.  
    Comparez le résultat entre la version calculée sur l'objet local et sur la base de donnée.
    ```{r, eval = FALSE}
    nycflights13::weather %>% 
      group_by(origin, year) %>%  summarise(avg_temp = mean(temp))
    ```
    ```{r, warning = FALSE}
    nycflights13_db[["weather"]] %>% 
      group_by(origin, year) %>% summarise(avg_temp = mean(temp))
    ```


## Exercices (Partie II) {#exe}

* Comptez le nombre d'aéroport dont le code `dest` (table `flights`) commence par la lettre "A" ([Wildcard SQL](https://www.w3schools.com/sql/sql_wildcards.asp); `%like%`).
    ```{r}
    nycflights13_db[["flights"]] %>% 
      filter(dest %like% 'A%') %>% 
      summarise(count = n_distinct(dest))
    ```

## Exercices (Partie II) {#exe}

* Créez une nouvelle colonne `origin_dest` à partir des colonnes `origin` et `dest`.
    ```{r}
    nycflights13_db[["flights"]] %>%
      mutate(origin_dest = origin %|| '-' ||% dest) %>%
      select(origin, dest, origin_dest)
    ```



## Pour aller plus loin ...

* Tutoriel SQL: [www.codecademy.com](https://www.codecademy.com/learn/learn-sql)

* Le SQL en 10 étapes : [blog.jooq.org](https://blog.jooq.org/2016/03/17/10-easy-steps-to-a-complete-understanding-of-sql/)


# 


## *dbplot* | Du *ggplot2* depuis une base de données {.flexbox .vcenter}

```{r, eval = FALSE}
library(DBI)
library(odbc)
library(tidyverse)
library(dbplyr)
library(dbplot)
library(sparklyr)

con <- spark_connect(master = "local")

ratings %>% 
  copy_to(con, ., "ratings") %>% 
  dbplot_boxplot(x = Year, var = IMDbRating)

dbDisconnect(con)
```




```{r, eval = FALSE, echo = TRUE, results = "hide", warning = FALSE, message = FALSE}
dbDisconnect(con)
con <- dbConnect(
  drv = odbc(),
  driver = "PostgreSQL ODBC Driver(UNICODE)",
  server = "localhost",
  port = 5432,
  database = "postgres",
  uid = "postgres",
  password = "password"
)
dbSendQuery(con, SQL("DROP DATABASE datawarehouse;"))
dbSendQuery(con, SQL("DROP ROLE rdb;"))
dbSendQuery(con, SQL("DROP DATABASE movies;"))
dbSendQuery(con, SQL("DROP ROLE imdb_user;"))
dbDisconnect(con)
# DROP DATABASE datawarehouse; DROP ROLE rdb; DROP DATABASE movies; DROP ROLE imdb_user;
```
